# Доработка ролевой модели

Предлагается добавить скоупы в текущие access zone ролей.

У нас сейчас есть следующие access zones:

```python
class AccessZoneSystem(str, enum.Enum):
    ADMINISTRATION = "Администрирование"
    ACCOUNT_EDITING = "Редактирование аккаунта"
    ACCOUNT_ADMIN_ASSIGNMENT = "Назначение администраторов аккаунта"
    PROJECT_EDITING = "Редактирование проектов"
    ADD_PROJECT_USER = "Добавление пользователей в проект"
    USER_EDITING = "Редактирование пользователей"
```

‍

**Добавить UI зоны.** 

‍

Однако, возникают проблемы с тем, что непонятно, как именно ограничивать эти зоны.

Пример: у нас есть администратор аккаунта (и предполагается, что он может менять/создавать пользователей в рамках своего аккаунта). Однако текущие зоны не позволяют это как-то ограничить, и такой администратор аккаунта будет иметь возможность изменять/создавать пользователей в других аккаунтах.

Поэтому предлагается к зонам добавить ещё и их скоуп.

Пример: `SYSTEM`​, `ACCOUNT`​.

Таким образом, сочетание зон и скоупов позволит ограничивать действия пользователей и болёё чётко задавать уровень их прав.

Например, `USER_EDITING + SYSTEM`​ - позволяет редактировать пользователей <u>всей</u> системы. `USER_EDITING + ACCOUNT`​- редактирование пользователей возможно только в пределах <u>аккаунта</u>.

---

Можно пойти чуть дальше, и ещё больше расширить модель.

Можно выделить набор объектов, а также набор действий над ними. Например, объекты - `PROJECT`​, `USER`​, `ROLE`​ и т.д. Набор действий - `READ`​, `EDIT`​ и т.д.

Скорее всего потребуется какое-то разграничение ещё и для `EDIT`​ - чтобы была возможность разграничивать действия вида "создаю и могу редактировать только свои объекты" и "создаю и могу редактировать любые объекты (в т.ч. чужие)" (например - через действие `EDIT_OWNED`​ или через дополнительный скоуп `OWNED`​) - *нужно будет подумать*.

Комбинируя `объект + действие + скоуп`​ можно гибко описывать правила.

Например: `PROJECT + EDIT + ACCOUNT`​ -> роль может редактировать проекты в рамках своего аккаунта. Если, при этом, нужны также права на просмотр списка проектов в других аккаунтах, то тогда получаем комбинацию `PROJECT + READ + SYSTEM`​. При этом мы можем сочетать набор таких комбинаций для одной роли. Например, возможность редактировать проекты в своём аккаунте И возможность видеть проекты во всей системе (но без возможности их редактировать).

Вопрос лишь в том - насколько нам это нужно.

---

Можно таким образом выделить список объектов и действий системной роли

||Объект|Скоуп|Действие|Описание|
| -| ------------| ----------| ----------------| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
||PROJECT|SYSTEM|READ|Возможность читать все проекты во всех аккаунтах|
||PROJECT|ACCOUNT|READ|Возможность читать проекты в пределах своего аккаунта|
||PROJECT|SYSTEM|EDIT|Возможность создавать проекты в любом аккаунте, а также редактировать любые проекты|
||PROJECT|ACCOUNT|EDIT|Возможность создавать проекты в своём аккаунте, а также редактировать любые проекты в аккаунте|
||USER|SYSTEM|READ|Возможность видеть пользователей всех аккаунтов|
||USER|ACCOUNT|READ|Возможность видеть пользователей своего аккаунта|
||USER|SYSTEM|EDIT|Возможность создавать и редактировать любого пользователя в любом аккаунте|
||USER|ACCOUNT|EDIT|Возможность создавать редактировать пользователей своего аккаунта|
||SYSTEM_ROLE||READ|Возможность просматривать системные роли|
||SYSTEM_ROLE||EDIT|Возможность изменять системные роли|
|||||Системные роли не имеют скоупа как такового, т.к. у нас роли распространяются на всю систему|
||PROJECT_ROLE||READ|Аналогично и с проектными ролями. Поскольку они у нас сейчас на всю систему - то и скоупа у них нет|
||PROJECT_ROLE||EDIT||

​`User.update`​ - только админская штука.

​`Me.updatePersonalData`​ - изменить только свои данные (персональные/пароль).

‍

Небольшая ремарка по редактированию пользователей. Мы позволяем менять роль пользователя, но только при условии, что новая роль пользователя - такая же или "меньше" роли того, кто меняет роль пользователя.

Сравнивать роли можно следующими способами:

1. По скоупам и действиям над скоупами. Например - `SYSTEM + EDIT`​ будет шире ("больше"), чем `ACCOUNT + EDIT`​. Однако будет вопрос в том, как сравнивать, например, `SYSTEM + READ`​ и `ACCOUNT + EDIT`​.
2. У каждой роли есть её приоритет. Он назначается администратором при создании этой роли.

Как по мне - вариант №2 будет гораздо проще.

‍

Системные роли может назначать только админ.

‍

‍

Как определять наличие доступа к UI админки. Тоже можно несколькими способами:

1. Определять по наличию права `EDIT`​.
2. Добавить у роли флаг, является ли она админской или нет (по сути это будет просто формальный флаг, т.к. права на самом деле определяются набором прав). - Вариант не совсем нравится, т.к. он не будет отражать реальной сути. Хоть, с другой стороны, он является самым простым.
3. Ввести какой-то объект `ADMIN_UI`​. Но тут тоже не очень нравится - у этого не будет ни скоупов, ни действий. Не будет смотреть органично.

<span data-type="text" style="background-color: var(--b3-font-background11);">Связь Роли + UI зона.</span>

---

Список ролей:

|Имя роли|Объект|Скоуп|Действие|
| -------------------------------------------| ------------| ----------| ----------------|
|Администратор SEISM||||
||PROJECT|SYSTEM|EDIT|
||USER|SYSTEM|EDIT|
||SYSTEM_ROLE||EDIT|
||PROJECT_ROLE||EDIT|
|Администратор аккаунта||||
||PROJECT|ACCOUNT|EDIT|
||USER|ACCOUNT|EDIT|
||SYSTEM_ROLE||READ|
||PROJECT_ROLE||READ|
|Пользователь||||
||USER|ACCOUNT|READ|
||SYSTEM_ROLE||READ|
||PROJECT_ROLE||READ|

---


name,           grant_role_level

SUPERADMIN		0

ADMIN_ACCOUNT		1

USER				2

GUEST				N

‍

‍

По проектным ролям примерно такой же подход можно сделать. Только уже без скоупов (т.к. по сути в проекте у нас только 1 скоуп может быть - `PROJECT`​).

|Primary Key|Объект|Действие|
| ----------------------------------------------------------------| -----------------| ----------------|
|Ответственный исполнитель|||
||PUBLIC_COLLECTION|EDIT|
||USER_COLLECTION|READ|
||USER_COLLECTION|EDIT_OWNED|
|Руководитель группы пользователей|||
||PUBLIC_COLLECTION|READ|
||PUBLIC_COLLECTION|EDIT_OWNED|
||USER_COLLECTION|EDIT_OWNED|
|Пользователь|||
||PUBLIC_COLLECTION|READ|
||USER_COLLECTION|EDIT_OWNED|
|Гость|||
||PUBLIC_COLLECTION|READ|

Кроме того, мы можем ввести любой другой набор дополнительных ключевых слов, связанных с объектами проекта: `GRAPH`​, `TASK`​, `LOGS`​ и так далее.

---

Авторизация при этом может выполняться через JWT. Мы в токен просто можем зашивать права на доступ к объектам. Пример:

```json
{
  "userUuid": "73a80ca3-147b-4453-b5ab-95c9b8ae88e3",
  "userLogin": "VlasovSV",
  "accountUuid": "13b54d4c-9f65-4a80-9e76-c1a5b922d81f",
  "projectUuid": "00000000-0000-0000-0000-000000000001",
  "exp": 1816094457.781391,
  
  /* Новые поля */
  "tokenUuid": "13b54d4c-9f65-4a80-9e76-c1a5b922d81f",

  "systemRoleAccesses": [
    {
      "obj": "PROJECT",
      "scope": "ACCOUNT",
      "act": "EDIT"
    },
    {
      "obj": "USER",
      "scope": "ACCOUNT",
      "act": "EDIT"
    },
    {
      "obj": "SYSTEM_ROLE",
      "scope": null,
      "act": "READ"
    },
    {
      "obj": "PROJECT_ROLE",
      "scope": null,
      "act": "READ"
    }
  ],

  "projectRoleAccesses": [
    {
      "obj": "PUBLIC_COLLECTION",
      "act": "READ"
    },
    {
      "obj": "USER_COLLECTION",
      "act": "EDIT_OWNED"
    },
    {
      "obj": "TASK",
      "act": "EDIT_OWNED"
    },
    {
      "obj": "GRAPH",
      "act": "EDIT"
    }
  ]
}
```

‍

Для возможности инвалидации токенов - можно хранить в Redis список валидных `tokenUuid`​. Как только токен по какой-то причине отзывается (например, изменение роли у пользователя или прав доступа у ролей) - он удаляется из списка валидных.

‍

‍
